stats::cor(x[valid], y[valid],
method="pearson", use="all.obs")
)
}
CMP(ls1, ls2, fun=cor_pearson2, w=3) %>% p
#' @name cmp_funs
#' @export
cor_pearson2 <- function(x, y, ...) {
valid <- !is.na(x) & !is.na(y)
if (sum(valid) == 0) return(0)
if (sum(valid)<2) return(0)
# suppress warning "the standard deviation is zero"
suppressWarnings(
stats::cor(x[valid], y[valid],
method="pearson", use="complete.obs")
)
}
CMP(ls1, ls2, fun=cor_pearson2, w=3) %>% p
#' @name cmp_funs
#' @export
cor_pearson2 <- function(x, y, ...) {
valid <- !is.na(x) & !is.na(y)
if (sum(valid) == 0) return(0)
if (sum(valid)<2) return(0)
# suppress warning "the standard deviation is zero"
suppressWarnings(
stats::cor(x[valid], y[valid],
method="pearson", use="na.or.complete")
)
}
CMP(ls1, ls2, fun=cor_pearson2, w=3) %>% p
#' @name cmp_funs
#' @export
cor_pearson2 <- function(x, y, ...) {
valid <- !is.na(x) & !is.na(y)
if (sum(valid) == 0) return(0)
if (sum(valid)<2) return(0)
# suppress warning "the standard deviation is zero"
suppressWarnings(
stats::cor(x[valid], y[valid],
method="pearson", use="pairwise.complete.obs")
)
}
CMP(ls1, ls2, fun=cor_pearson2, w=3) %>% p
ls1 %>% p
ls2 %>% p
ls2 %>% values %>% unique
ls1 %>% values %>% unique()
ls1 %>% raster_classes()
ls2 %>% raster_classes()
ls1[1, 1]
ls1[1, 1] %>% is.na
devtools::load_all(".")
devtools::load_all(".")
CMP(ls1, ls2, fun=cor_pearson2, w=3) %>% p
#' @name cmp_funs
#' @export
cor_pearson2 <- function(x, y, ...) {
valid <- !is.na(x) & !is.na(y)
if (sum(valid) == 0) return(0)
if (sum(valid)<2) return(0)
# suppress warning "the standard deviation is zero"
suppressWarnings(
stats::cor(x[valid], y[valid],
method="pearson", use="pairwise.complete.obs")
)
}
CMP(ls1, ls2, fun=cor_pearson2, w=3) %>% p
p(ls1)
p(ls2)
p(ls1)
CMP(ls1, ls2, fun=kappa_index, w=3) %>% p
source("~/Research/mucha/R/CMP.R")
devtools::load_all(".")
CMP(ls1, ls2, fun=kappa_index, w=3) %>% p
devtools::load_all(".")
devtools::load_all(".")
CMP(ls1, ls2, fun=kappa_index, w=3) %>% p
CMP(ls1, ls2, fun=kappa_index, w=3) %>% p
CMP(ls1, ls2, fun=cor, w=3) %>% p
CMP(ls1, ls2, fun=cor_pearson, w=3) %>% p
cor(rep(1:5), rep(2:5))
cor(rep(1:5), rep(2, 5))
cor(rep(1,5), rep(2, 5))
cov(rep(1,5), rep(2, 5))
contagion
usethis::use_rcpp()
Rcpp::compileAttributes()
Rcpp::compileAttributes()
devtools::load_all(".")
devtools::load_all(".")
rm(list = c("CMP", "cor_pearson", "dist_euclidean"))
devtools::load_all(".")
l1 <- import_example("l1.tif") %>% raster_resample(0.2)
MHM(l1, fun=contagion_cppr)
seq_along(c(1, 4, 5))
MHM2 <- function(x,
window=window_quick(),
kernel=kernel_circle,
fun=mean,
na.policy="omit",
fillvalue=NA,
expand=FALSE,
na.rm=TRUE,
...){
res <- vector("list", length=length(window))
# calculate
for (i in seq_along(window)){
cat("*")
res[[i]] <- terra::focal(x, w=kernel(window[i]),
fun=fun,
na.policy=na.policy,
fillvalue=fillvalue,
expand=expand,
na.rm=na.rm,
...)
}
# combine into a multilayer SpatRaster
res <- purrr::reduce(res, c)
# name layers with window sizes
names(res) <- paste0("w=", as.character(window))
# return this beauty
res
}
MHM(l1, fun=richness)
MHM(l1, fun=contagion_cppr)
MHM2(l1, fun=richness)
MHM2(l1, fun=contagion_cppr)
contagion_cppr
MHM2(l1, fun=contagion_cpp)
terra::focal(l1, w=3, fun=contagion_cpp)
terra::focal(l1, w=3, fun=function(z, ...) contagion_cpp(z, ...))
terra::focal
?terra::focal
terra::focal(l1, w=3, fun="contagion_cpp")
# Create a simple test raster
r <- rast(ncol=10, nrow=10, xmin=0, xmax=10, ymin=0, ymax=10)
values(r) <- sample(1:3, 100, replace=TRUE)
# Test the function directly on a window
test_window <- values(r)[1:9]  # 3x3 window
contagion_cpp(test_window)
test_window
contagion_cpp(test_window)
contagion_cppr(test_window)
devtools::load_all(".")
contagion_cppr(test_window)
Rcpp::compileAttributes()
contagion_cppr(test_window)
contagion(test_window)
contagion_cpp(test_window)
contagion_cppr(test_window)
usethis::use_rcpp()
devtools::load_all(".")
Rcpp::compileAttributes()
devtools::load_all(".")
contagion_cppr(1:49)
Rcpp::compileAttributes()
usethis::use_rcpp()
devtools::load_all(".")
contagion_cppr(test_window)
contagion_cpp(test_window)
l1 <- import_example("l1.tif") %>% raster_resample(0.2)
MHM(l1, fun=richness)
MHM(l1, fun=contagion_cppr)
MHM(l1, fun=contagion_cppr)
MHM(l1, fun=contagion_cppr) %>% p()
MHM(l1, fun=contagion) %>% p()
microbenchmark::microbenchmark(
MHM(l1, fun=contagion),
MHM(l1, fun=contagion_cppr),
times=1)
58.24700/1.37939
microbenchmark::microbenchmark(
MHM(l1, fun=contagion, w=41),
MHM(l1, fun=contagion_cppr, w=41),
times=1)
122.399504/3.907
devtools::load_all(".")
?contagion
shannon_evenness()
shannon_evenness
devtools::load_all(".")
l1
import_example("l1.tif")
l1 <- import_example("l1.tif")
l1 %>% MHM(fun=shannon_evenness, w=9)
devtools::load_all(".")
l1 %>% MHM(fun=shannon_evenness, w=9)
l1 %>% MHM(fun=shannon_evenness_cppr, w=9)
l1 %>% MHM(fun=shannon_evenness_cpp, w=9)
l1 %>% MHM(fun=shannon_evenness_cppr, w=9)
microbenchmark::microbenchmark(
z1 <- l1 %>% MHM(fun=shannon_evenness, w=9),
z2 <- l1 %>% MHM(fun=shannon_evenness_cppr, w=9),
times=1)
microbenchmark::microbenchmark(
z1 <<- l1 %>% MHM(fun=shannon_evenness, w=9),
z2 <<- l1 %>% MHM(fun=shannon_evenness_cppr, w=9),
times=1)
38.870165/5.6
devtools::load_all(".")
microbenchmark::microbenchmark(
z1 <<- l1 %>% MHM(fun=kappa_index, w=9),
z2 <<- l1 %>% MHM(fun=kappa_index_cppr, w=9),
times=1)
263/6.12
z1
z1 %>% p
z2 %>% p
devtools::load_all(".")
shannon_cpp
l1
devtools::load_all(".")
l1 %>% MHM(fun=shannon)
l1 %>% MHM(fun=shannon) -> z1
l1 %>% raster_resample() %>% MHM(fun=shannon) -> z1
l1 %>% raster_resample(0.1) %>% MHM(fun=shannon) -> z1
l1 %>% raster_resample(0.1) %>% MHM(fun=shannon_cppr) -> z1
l1 %>% raster_resample(0.1) %>% MHM(fun=shannon) -> z1
l1 %>% raster_resample(0.2) %>% MHM(fun=shannon) -> z1
l1 %>% raster_resample(0.2) %>% MHM(fun=shannon_cppr) -> z1
l1 %>% raster_resample(0.2) %>% MHM(fun=shannon_cppr) -> z2
l1 %>% raster_resample(0.2) %>% MHM(fun=shannon) -> z1
z2 %>% p
z1 %>% p
z2 %>% app(median) %>% p
z1 %>% app(median) %>% p
microbenchmark::microbenchmark(
z1 <<- l1 %>% MHM(fun=shannon),
z2 <<- l1 %>% MHM(fun=shannon_cppr),
times=1)
277.28878/35
shannon_cppr(sample(1:4, size=49, rep=T))
shannon(sample(1:4, size=49, rep=T))
set.seed(2329) # for reproducibility
x <- sample(1:3, size=49, replace=TRUE, prob=c(0.1, 0.1, 1))  # unbalanced vector
table(x)
x %>% richness()
x %>% simpson()
x %>% simpson_cppr()
x %>% shannon()
x %>% shannon_cppr()
x %>% shannon_evenness()
x %>% shannon_evenness_cppr()
x %>% kappa_index()
x %>% kappa_index_cppr()
x %>% contagion()
x %>% contagion_cppr(()
x %>% kappa_index()
set.seed(2329) # for reproducibility
x <- sample(1:3, size=50, replace=TRUE, prob=c(0.1, 0.1, 1))  # unbalanced vector
y <- sample(1:3, size=50, replace=TRUE, prob=c(0.1, 0.1, 1))  # another one
x <- sample(1:3, size=49, replace=TRUE, prob=c(0.1, 0.1, 1))  # unbalanced vector
y <- sample(1:3, size=49, replace=TRUE, prob=c(0.1, 0.1, 1))  # another one
# examples runs mostly to test and exemplify
# but in CMP they will run on each pair of focal windows
# built in functions
cor(x, y)
cov(x, y)
# distance indices
dist_euclidean(x, y)
dist_euclidean_cppr(x, y)
devtools::load_all(".")
set.seed(2329) # for reproducibility
x <- sample(1:3, size=49, replace=TRUE, prob=c(0.1, 0.1, 1))  # unbalanced vector
y <- sample(1:3, size=49, replace=TRUE, prob=c(0.1, 0.1, 1))  # another one
# examples runs mostly to test and exemplify
# but in CMP they will run on each pair of focal windows
# built in functions
cor(x, y)
cov(x, y)
# distance indices
dist_euclidean(x, y)
dist_euclidean_cppr(x, y)
dist_manhattan(x, y)
dist_manhattan_cppr(x, y)
dist_chebyshev(x, y)
dist_chebyshev_cppr(x, y)
dist_bhat(x, y)
# difference indices
diff_rmse(x, y)
diff_rmse_cppr(x, y)
diff_mean(x, y)
diff_median(x, y)
diff_var(x, y)
diff_cv(x, y)
# p value from Student t test
p_student(x, y)
p_wilcoxon(x, y)
p_wilcoxon(x, y)
devtools::load_all(".")
library(terra)
library(mucha)
l1 <- import_txt("original_data/landex1.txt", na="-9999") # MHM
l2 <- import_txt("original_data/landex2.txt", na="-9999") # CMP
c(l1, l2) %>% p()
ws <- odd_floor(seq(10, 100, 10))
ws
t0_mhm <- Sys.time()
l1_mhm <- MHM(l1, window = ws, fun=shannon_evenness_cppr)
t1_mhm <- Sys.time() - t0_mhm
t1_mhm # time elapsed # ~1h20
# export this beauty
l1_mhm %>% export_spatraster_grid("ignore/mhm_evenness.txt")
# export this beauty
l12_cmp_euc %>% export_txt_grid("ignore/cmp_euc.txt")
t1_mhm
# export this beauty
l1_mhm %>% export_txt_grid("ignore/mhm_evenness.txt")
l1_mhm
getwd()
# export this beauty
l1_mhm %>% export_txt_grid("mhm_evenness.txt")
t0_cmp_euc <- Sys.time()
l12_cmp_euc <- CMP(l1, l2, window = ws, fun=dist_euclidean_cppr)
t1_cmp_euc <- Sys.time() - t0_cmp_euc
t1_cmp_euc # time elapsed ~35 min
# export this beauty
l12_cmp_euc %>% export_txt_grid("cmp_euc.txt")
t0_cmp_cor <- Sys.time()
l12_cmp_cor <- CMP(l1, l2, window = ws, fun=cor_pearson)
t1_cmp_cor <- Sys.time() - t0_cmp_cor
t1_cmp_cor # time elapsed ~35min
# export this beauty
l12_cmp_cor %>% export_txt_grid("cmp_cor.txt")
mhm_eveness_mucha_mono <- import_txt_grid("mhm_evenness.txt")
mhm_eveness_mucha_mono <- import_txt_grid("mhm_evenness.txt")
cmp_cor_mucha_mono     <- import_txt_grid("cmp_cor.txt")
cmp_cor_mucha_mono     <- import_txt_grid("cmp_cor.txt")
cmp_dist_mucha_mono    <- import_txt_grid("cmp_euc.txt")
mhm_eveness_mucha <- app(mhm_eveness_mucha_mono, mean)
cmp_cor_mucha     <- app(cmp_cor_mucha_mono, mean)
cmp_dist_mucha    <- app(cmp_dist_mucha_mono, mean)
import_legacy <- function(x){
x %>%
readLines() %>%
gsub(" +", " ", .) %>%
gsub("-9999.0", "NA", .) %>%
utils::read.table(text=., sep=" ", header=F)  %>%
as.matrix() %>%
terra::rast()
}
mhm_eveness_legacy <- import_legacy("legacy_data/Even_multiScales/average.txt")
cmp_cor_legacy     <- import_legacy("legacy_data/Corr_multiScales/average.txt")
cmp_dist_legacy    <- import_legacy("legacy_data/Dist_multiScales/average.txt")
p(l1, title="original")
p(mhm_eveness_mucha, title="mucha eveness")
p(mhm_eveness_legacy, title="legacy eveness")
p(c(l1, l2), title="original")
p(app(cmp_dist_mucha_mono, prod), title="mucha euc dist")
p(cmp_dist_legacy, title="legacy euc dist")
p(c(l1, l2), title="original")
p(cmp_cor_mucha, title="mucha euc dist")
p(cmp_cor_legacy, title="legacy euc dist")
p(c(l1, l2), title="original")
p(cmp_cor_mucha, title="mucha cor")
p(cmp_cor_legacy, title="legacy cor")
cmp_cor_mucha_mono %>% p
p(app(cmp_dist_mucha_mono, mean), title="mucha euc dist")
p(c(l1, l2), title="original")
p(app(cmp_dist_mucha_mono, mean), title="mucha euc dist")
p(cmp_dist_legacy, title="legacy euc dist")
p(app(cmp_dist_mucha_mono, sum), title="mucha euc dist")
p(c(l1, l2), title="original")
p(app(cmp_dist_mucha_mono, sum), title="mucha euc dist")
p(cmp_dist_legacy, title="legacy euc dist")
mhm_eveness_mucha <- app(mhm_eveness_mucha_mono, mean, na.rm=T)
cmp_cor_mucha     <- app(cmp_cor_mucha_mono, mean, na.rm=T)
cmp_dist_mucha    <- app(cmp_dist_mucha_mono, mean, na.rm=T)
import_legacy <- function(x){
x %>%
readLines() %>%
gsub(" +", " ", .) %>%
gsub("-9999.0", "NA", .) %>%
utils::read.table(text=., sep=" ", header=F)  %>%
as.matrix() %>%
terra::rast()
}
mhm_eveness_legacy <- import_legacy("legacy_data/Even_multiScales/average.txt")
cmp_cor_legacy     <- import_legacy("legacy_data/Corr_multiScales/average.txt")
cmp_dist_legacy    <- import_legacy("legacy_data/Dist_multiScales/average.txt")
p(l1, title="original")
p(mhm_eveness_mucha, title="mucha eveness")
p(mhm_eveness_legacy, title="legacy eveness")
mhm_eveness_mucha %>% values %>% hist(main="mucha")
mhm_eveness_legacy %>% values %>% hist(main="legacy")
kappa_index(sample(1:4, 49, rep=T))
kappa_index(sample(1:4, 49, rep=T))
kappa_index(sample(1:4, 49, rep=T))
kappa_index(sample(1:4, 49, rep=T))
kappa_index(sample(1:4, 49, rep=T))
devtools::load_all(".")
devtools::load_all(".")
kappa_index(sample(1:4, 49, rep=T))
kappa_index(sample(1:4, 49, rep=T))
kappa_index_two_maps <- function(x, y, ...) {
# x and y are vectors from two different maps/focal windows
# Calculate kappa agreement between them
# Check that vectors are same length
if (length(x) != length(y)) {
stop("Vectors x and y must have the same length")
}
# Reconstruct matrices from vectors (assuming square windows)
window_size <- sqrt(length(x))
if (window_size != as.integer(window_size)) {
stop("Vector length must be a perfect square for square windows")
}
mat_x <- matrix(x, nrow = window_size, ncol = window_size, byrow = TRUE)
mat_y <- matrix(y, nrow = window_size, ncol = window_size, byrow = TRUE)
# Get valid pairs (both values must be non-NA)
valid_idx <- !is.na(x) & !is.na(y)
x_valid <- x[valid_idx]
y_valid <- y[valid_idx]
# Need at least 2 valid pairs
if (length(x_valid) < 2) {
return(NA_real_)
}
# Get all unique classes across both maps
classes <- sort(unique(c(x_valid, y_valid)))
n_classes <- length(classes)
# If only one class, kappa is 0 (no variability to agree/disagree on)
if (n_classes == 1) {
return(0)
}
# Build confusion matrix (contingency table)
# Rows = map x, Columns = map y
confusion_matrix <- matrix(0, nrow = n_classes, ncol = n_classes)
rownames(confusion_matrix) <- colnames(confusion_matrix) <- as.character(classes)
# Fill confusion matrix
for (i in 1:length(x_valid)) {
class_x <- as.character(x_valid[i])
class_y <- as.character(y_valid[i])
confusion_matrix[class_x, class_y] <- confusion_matrix[class_x, class_y] + 1
}
# Total number of valid pairs
n_total <- sum(confusion_matrix)
# Calculate observed agreement (Po)
# Proportion of diagonal elements (where both maps agree)
Po <- 0
for (i in 1:n_classes) {
class_name <- as.character(classes[i])
Po <- Po + confusion_matrix[class_name, class_name]
}
Po <- Po / n_total
# Calculate expected agreement by chance (Pe)
# For each class: (marginal_x / n) * (marginal_y / n)
Pe <- 0
for (i in 1:n_classes) {
class_name <- as.character(classes[i])
# Marginal probabilities
p_x <- sum(confusion_matrix[class_name, ]) / n_total
p_y <- sum(confusion_matrix[, class_name]) / n_total
Pe <- Pe + (p_x * p_y)
}
# Calculate Cohen's Kappa
# Kappa = (Po - Pe) / (1 - Pe)
if (Pe >= 1) {
# Avoid division by zero
return(0)
}
kappa <- (Po - Pe) / (1 - Pe)
return(as.numeric(kappa))
}
kappa_index_two_maps(sample(1:4, 49, rep=T), sample(1:4, 49, rep=T))
kappa_index_two_maps(sample(1:4, 49, rep=T), sample(1:4, 49, rep=T))
kappa_index_two_maps(sample(1:4, 49, rep=T), sample(1:4, 49, rep=T))
kappa_index_two_maps(sample(1:4, 49, rep=T), sample(1:4, 49, rep=T))
kappa_index_two_maps(sample(1:4, 49, rep=T), sample(1:4, 49, rep=T))
devtools::load_all(".")
l1 <- import_example("l1.tif") %>% raster_resample(0.2)
l2 <- import_example("l2.tif") %>% raster_resample(0.2)
CMP(l1, l2, fun=kappa_index_cppr) -> x
x %>% p
l2 <- import_example("l2.tif")
l1 <- import_example("l1.tif")
CMP(l1, l2, fun=kappa_index_cppr) -> x
set.seed(2329) # for reproducibility
x <- sample(1:3, size=49, replace=TRUE, prob=c(0.1, 0.1, 1))  # unbalanced vector
y <- sample(1:3, size=49, replace=TRUE, prob=c(0.1, 0.1, 1))  # another one
# examples runs mostly to test and exemplify
# but in CMP they will run on each pair of focal windows
# built in functions
cor(x, y)
cov(x, y)
# kappa agreement
kappa_index(x, y)
kappa_index_cppr(x, y)
# distance indices
dist_euclidean(x, y)
dist_euclidean_cppr(x, y)
#' @rdname cmp_funs
#' @export
dist_equal <- function(x, y, ...) {
valid <- !is.na(x) & !is.na(y)
if (sum(valid) == 0) return(NA)
sum(x[valid] == y[valid])/sum(valid)
}
#' @rdname cmp_funs
#' @export
dist_different <- function(x, y, ...) {
valid <- !is.na(x) & !is.na(y)
if (sum(valid) == 0) return(NA)
sum(x[valid] != y[valid])/sum(valid)
}
dist_equal(x, y)
data.frame(x=x, y=y)
data.frame(x=x, y=y) %>% apply(1, equal)
data.frame(x=x, y=y) %>% apply(1, function(x) x[1]==x[2])
data.frame(x=x, y=y) %>% apply(1, function(x) x[1]==x[2]) %>% sum()
29/49
dist_equal(x, y)
dist_different(x, y)
